

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Algorithms &mdash; F1tenth latest documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/js/custom.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../_static/css/custom.css" type="text/css" />
    <link rel="alternate" hreflang="en" href="https://docs.godotengine.org/en/" />
    <link rel="alternate" hreflang="de" href="https://docs.godotengine.org/de/" />
    <link rel="alternate" hreflang="es" href="https://docs.godotengine.org/es/" />
    <link rel="alternate" hreflang="fr" href="https://docs.godotengine.org/fr/" />
    <link rel="alternate" hreflang="ko" href="https://docs.godotengine.org/ko/" />
    <link rel="alternate" hreflang="pl" href="https://docs.godotengine.org/pl/" />
    <link rel="alternate" hreflang="pt-br" href="https://docs.godotengine.org/pt-br/" />
    <link rel="alternate" hreflang="uk" href="https://docs.godotengine.org/uk/" />
    <link rel="alternate" hreflang="zh-cn" href="https://docs.godotengine.org/zh-cn/" />
    <link rel="alternate" hreflang="x-default" href="https://docs.godotengine.org/" />
    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Contact" href="../contact.html" />
    <link rel="prev" title="Simulation" href="simulation.html" />


  <script type="text/javascript">
    <!-- Adds target=_blank to external links -->

    $(document).ready(function () {
      $('a[href^="http://"], a[href^="https://"]').not('a[class*=internal]').attr('target', '_blank');
    });
  </script>

 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html">
          

          
            
            <img src="../_static/f1_stickers_02.png" class="logo" alt="Logo"/>
          
          </a>

          
            
            
              <div class="version">
                latest
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/build_car.html">Building the Car</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/build_car.html#preparing-and-assembling-the-car">Preparing and Assembling the Car</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#preparing-the-car">Preparing the Car</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#installing-the-body-standoffs">Installing the Body Standoffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-focbox-to-the-chassis">Mounting the FOCbox to the Chassis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#installing-the-chassis-standoffs">Installing the Chassis Standoffs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#detaching-the-jetson-from-the-development-board">Detaching the Jetson from the Development Board</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-wi-fi-antennas-to-the-power-board">Mounting the Wi-Fi Antennas to the Power Board</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-power-board-to-the-chassis">Mounting the Power Board to the Chassis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#attaching-the-orbitty-to-the-jetson">Attaching the Orbitty to the Jetson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#connecting-the-jetson-and-power-board">Connecting the Jetson and Power Board</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-jetson-to-the-chassis">Mounting the Jetson to the Chassis</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-chassis-to-the-car-underbody">Mounting the Chassis to the Car Underbody</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-lidar">Mounting the LIDAR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#mounting-the-usb-hubs">Mounting the USB Hubs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#connecting-the-lidar">Connecting the LIDAR</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#connecting-the-focbox">Connecting the FOCbox</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/build_car.html#connecting-the-car-to-the-battery">Connecting the Car to the Battery</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/software_setup/index.html">Software Setup</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/software_setup/software_host.html">Host/Laptop Setup</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_host.html#installing-ubuntu">Installing Ubuntu</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_host.html#installing-ros">Installing ROS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html">Jetson Setup</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html#connect-terminals-to-the-jetson-aka-the-device">Connect terminals to the Jetson (aka “the device”)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html#install-linux">1. Install Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html#flashing-the-jetpack">2. Flashing the Jetpack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html#re-flashing-the-orbitty">3. Re-flashing the Orbitty</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_jetson.html#installing-ros">4. Installing ROS</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/software_setup/software_combine.html">Bringing the Host and Jetson Together</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#connecting-the-jetson-car-to-the-access-point">Connecting the Jetson/Car to the Access Point</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#connecting-your-host-laptop-to-the-access-point">Connecting Your Host/Laptop to the Access Point</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#linux">Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#windows">Windows</a></li>
<li class="toctree-l4"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#mac-os">Mac OS</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#sshing-into-the-car">SSHing into the Car</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#setting-up-wireless-hot-spot-on-jetson">Setting Up Wireless Hot Spot on Jetson</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/software_setup/software_combine.html#setting-up-vnc-server-on-jetson">Setting Up VNC Server on Jetson</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/firmware.html">Installing Firmware</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#tuning-the-focboxs-pid-gains">Tuning the FOCbox’s PID Gains</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#hokuyo-10lx-ethernet-connection-setup">Hokuyo 10LX Ethernet Connection Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#working-directory-setup">Working Directory Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#udev-rules-setup">Udev Rules Setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#manual-control">Manual Control</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/firmware.html#troubleshooting">Troubleshooting</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/firmware.html#tuning-the-vesc-parameters">Tuning the VESC Parameters</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#testing-the-lidar-usb-only">Testing the Lidar (USB Only)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/firmware.html#recording-bag-data-on-the-car">Recording Bag Data on the Car</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/appendix/index.html">Appendices</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/appendix/appendix_a.html">Appendix A: Flashing Jetpack via a VM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/appendix/appendix_a.html#spin-up-an-ubuntu-vm">1.2 Spin up an Ubuntu VM</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/appendix/appendix_a.html#download-nvidia-jetpack">1.3 Download NVIDIA JetPack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/appendix/appendix_a.html#install-jetpack">1.4 Install JetPack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/appendix/appendix_a.html#validation-flash">1.5 Validation Flash</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/appendix/appendix_b.html">Appendix B: Shared Folders between Host and VM</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../getting_started/faq.html">FAQ</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#general">General</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#mechanical">Mechanical</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#do-i-have-a-broken-drive-train-how-can-i-fix-it">Do I have a broken drive train? How can I fix it?</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#differential-makes-excessive-noise">Differential makes excessive noise…</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#im-not-able-to-steer-the-car-no-response-from-the-steering-servo">I’m not able to steer the car, no response from the steering servo…</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#system-identification-failure-and-vesc-tuning">System identification failure and VESC tuning…</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#wireless-network">Wireless Network</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#high-packet-loss-excessive-latency-on-wireless-network">High packet-loss, excessive latency on wireless network…</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#increasing-range-of-the-gamepad">Increasing range of the gamepad</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#software">Software</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#vesc-serial-failures-vesc-hardware-and-software-revisions">VESC serial failures, VESC hardware and software revisions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#lidar-variants">LIDAR variants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../getting_started/faq.html#installing-pytorch">Installing pyTorch</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../getting_started/faq.html#additional-resources">Additional Resources</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#kernel">Kernel</a></li>
<li class="toctree-l2"><a class="reference internal" href="../getting_started/faq.html#simulation-and-experiments-without-hardware">Simulation and Experiments without Hardware</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Going Forward</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="simulation.html">Simulation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#want-a-different-navigation-algorithm">Want a Different Navigation Algorithm?</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#want-a-different-track">Want a Different Track?</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#dont-want-the-gui">Don’t Want the GUI?</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#moving-the-car-manually-in-simulation">Moving the Car Manually in Simulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="simulation.html#creating-a-world">Creating a World</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#wall-following">Wall Following</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#wall-following-with-explicit-instructions">Wall Following with Explicit Instructions</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gap-finding-in-lidar-scans-houssam">Gap-finding in LiDAR Scans [Houssam]</a></li>
<li class="toctree-l2"><a class="reference internal" href="#scan-matching-odometry-sheil">Scan Matching Odometry [Sheil]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#installing-packages">Installing Packages</a></li>
<li class="toctree-l3"><a class="reference internal" href="#getting-the-example-launch-file">Getting the Example Launch File</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#localization">Localization</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#localization-with-hector-slam">Localization with Hector SLAM</a></li>
<li class="toctree-l3"><a class="reference internal" href="#localization-with-amcl-adaptive-monte-carlo-localization">Localization with AMCL (Adaptive Monte Carlo Localization)</a></li>
<li class="toctree-l3"><a class="reference internal" href="#localization-with-particle-filter-faster-and-more-accurate-than-amcl">Localization with Particle Filter (Faster and More Accurate than AMCL)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-waypoints">Working with Waypoints</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generating-waypoints">Generating Waypoints</a></li>
<li class="toctree-l3"><a class="reference internal" href="#following-waypoints-with-pure-pursuit">Following Waypoints with Pure Pursuit</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pure-pursuit-speed-control-algorithm">Pure Pursuit Speed Control Algorithm</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#path-planning">Path Planning</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#path-planning-with-ros-move-base">Path Planning with ROS move_base</a></li>
<li class="toctree-l3"><a class="reference internal" href="#path-planning-with-teb-timed-elastic-band-local-planner">Path Planning with TEB (Timed Elastic Band) Local Planner</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Support</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../contact.html">Contact</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">F1tenth</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>Algorithms</li>
    
    


      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/godotengine/godot-docs/blob/master/going_forward/algorithms.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    


  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="algorithms">
<span id="doc-going-forward-algorithms"></span><h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h1>
<p>Here are just a handful of algorithms that we’ve implemented. Feel free to create your own!</p>
<div class="section" id="wall-following">
<h2>Wall Following<a class="headerlink" href="#wall-following" title="Permalink to this headline">¶</a></h2>
<p>With our Hokuyo lidar sensor attached to the car, one of the simplest algorithms we can run is a wall following algorithm. The basic idea is that the car uses the lidar sensor to measure the distance to either the left wall, right wall, or both walls, and tries to maintain a certain distance from the wall. Inside the wall_following package under <code class="docutils literal notranslate"><span class="pre">/launch</span></code> you will see a file called <code class="docutils literal notranslate"><span class="pre">wall_following.launch</span></code>.</p>
<p>Run the following commands in terminal in order to see the robot do a simple left wall follow in Gazebo simulator.</p>
<p>In one terminal run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roscore
</pre></div>
</div>
<p>In a second terminal, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ ​source​ devel/setup.bash
$​ roslaunch wall_following wall_following.launch
</pre></div>
</div>
<p>Now you should see the Gazebo simulator load with the car placed at the origin in our Levine Building 2nd floor world. The car tries to maintain a certain distance of 0.5 meters from the left all, and will continue following it around left turns in a counter-clockwise fashion. How is the code organized? From a high level view, data passes in this order:
<code class="docutils literal notranslate"><span class="pre">pid_error.py</span> <span class="pre">-&gt;</span> <span class="pre">control.py</span> <span class="pre">-&gt;</span> <span class="pre">sim_connector.py</span></code></p>
<p>The main code for the wall_following is under <code class="docutils literal notranslate"><span class="pre">wall_following/scripts/pid_error.py</span></code>. In this script you will find methods for <code class="docutils literal notranslate"><span class="pre">followLeft</span></code>, <code class="docutils literal notranslate"><span class="pre">followRight</span></code>, and <code class="docutils literal notranslate"><span class="pre">followCenter</span></code>.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">Pid_error.py</span></code> subscribes to the laser scan <code class="docutils literal notranslate"><span class="pre">/scan</span></code> topic and calls the callback function each time it gets new lidar data (around 40 times per second). It uses PID to calculate the error and adjusts the steering angle accordingly in order to try to keep its desired trajectory a certain distance away from the wall. <code class="docutils literal notranslate"><span class="pre">Pid_error.py</span></code> then outputs over the <code class="docutils literal notranslate"><span class="pre">/error</span></code> topic a message type we custom defined called pid_input which contains pid_vel and pid_error.</li>
<li><code class="docutils literal notranslate"><span class="pre">Control.py</span></code> subscribes to the <code class="docutils literal notranslate"><span class="pre">/error</span></code> topic and limits the car’s turning angle to 30 degrees and slows down the car when it is making a turn, or speeds up the car when it is going straight. <code class="docutils literal notranslate"><span class="pre">Control.py</span></code> publishes to the <code class="docutils literal notranslate"><span class="pre">/drive_parameters</span></code> topic using our custom message type called drive_param which contains velocity and angle.</li>
<li><code class="docutils literal notranslate"><span class="pre">sim_connector.py</span></code> subscribes to <code class="docutils literal notranslate"><span class="pre">/drive_parameters</span></code> and basically repackages the velocity and steering angle data into the <code class="docutils literal notranslate"><span class="pre">AckermannDriveStamped</span></code> message type so that it can be read in by the simulator under the <code class="docutils literal notranslate"><span class="pre">/vesc/ackermann_cmd_mux/input/teleop</span></code> topic.</li>
</ul>
<p>If you run the Gazebo simulator long enough, you’ll notice that when the car reaches around ¾ of the way through the track, it encounter an opening on the left that leads to a dead-end. Because the car is programmed to just do a wall follow, it gets stuck here. How might we alleviate this problem? With hard-coded turn instructions, as described in the next section.</p>
<p>If you want to try running the wall following in the real world, run these instructions. Depending on how wide the hallway is that the car is driving in, you may want to modify the parameters for <code class="docutils literal notranslate"><span class="pre">LEFT_DISTANCE</span></code> and <code class="docutils literal notranslate"><span class="pre">RIGHT_DISTANCE</span></code> at the top of the <code class="docutils literal notranslate"><span class="pre">pid_error.py</span></code> file.</p>
<p>In one terminal run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roscore
</pre></div>
</div>
<p>In a second terminal, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ ​source​ devel/setup.bash
$​ roslaunch real_world_wall_following wall_following.launch
</pre></div>
</div>
<div class="section" id="wall-following-with-explicit-instructions">
<h3>Wall Following with Explicit Instructions<a class="headerlink" href="#wall-following-with-explicit-instructions" title="Permalink to this headline">¶</a></h3>
<p>If we do a simple wall follow (left, right, or center), the robot will always make turns at openings it sees. But sometimes we may not want the robot to turn into an opening because it dead ends, or we just want it to keep going down the hallway. The idea in this section is to give the robot a sequence of turn instructions, which it calls sequentially each time it sees an opening. For instance, imagine in the Levine World telling the robot to turn [“left”, “left”, “left”, “center”, “left”]. The “center” would allow it to skip the dead end opening and continue straight with a center wall follow instead. Explicit instructions also includes velocity instructions.</p>
<p>To run the hard-coded turn instructions code in the simulator, do the following in your terminal.</p>
<p>In one terminal run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roscore
</pre></div>
</div>
<p>In a second terminal, run:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ ​ source​ devel/setup.bash
$​ roslaunch real_world_wall_following_explicit_instructions.Launch
</pre></div>
</div>
<p>To change the instructions, navigate to the <code class="docutils literal notranslate"><span class="pre">explicit_instructions/instructions.csv</span></code> file and change the values. You will see something that looks like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>left, <span class="m">1</span>.5
left, <span class="m">2</span>.0
left, <span class="m">1</span>.0
center, <span class="m">0</span>.5
left, <span class="m">2</span>.0
center, <span class="m">1</span>.5
stop, <span class="m">0</span>.0
</pre></div>
</div>
<p>The first value is the turn instruction and the second value is the velocity which gets executed after making that turn for some duration of time specified in the <code class="docutils literal notranslate"><span class="pre">pid_error_explicit_instructions.py</span></code> file.</p>
<p>The core logic is contained in the file <code class="docutils literal notranslate"><span class="pre">wall_following/scripts/pid_error_explicit_instructions.py</span></code>. There are a lot of comments in the code that describe the algorithm. At a high level, the car is constantly scanning for an opening by subscribing to the laser scan data. If the car detects an opening, then it takes the next instruction off of the turn instruction array and commits to that turn instruction for a specified number of seconds. The reason we commit for some seconds is that we don’t want the car to mistakenly think it sees a “new” opening midway through a turn, and prematurely call the next turn instruction.</p>
<p>How does the robot detect an opening? The robot scans to the right (and left as well) between some window of degrees. It compares lidar scans sequentially (so for instance, 0 degrees vs 0.25 degrees) and checks if the distance measured to 0 degrees and the distance measured to 0.25 degrees has a difference of some distance in meters. If there is a dropoff distance, then we know there is an opening.</p>
<p>A challenge we ran into is reflections off of metal plates on the doors in Levine Building. The robot calculated these as openings because Lidar data showed the points reflecting off the metal to be 60 meters away! Our solution was to ignore points that were further than 40 meters away because we know that they are metal.</p>
<p>You will also notice that in the <code class="docutils literal notranslate"><span class="pre">real_world_wall_following_explicit_planning.launch</span></code> file, we call a <code class="docutils literal notranslate"><span class="pre">dead_mans_switch.py</span></code> node. This allows us to use the joystick and the car only moves when the top right dead mans switch bumper is held down. This is for safety reasons.</p>
<p>If you notice your car is oscillating a lot on straightaways, try turning the kp value down in <code class="docutils literal notranslate"><span class="pre">control.py</span></code>.</p>
<p>Wall following with hard coded turns is a tedious algorithm because it requires us to manually predict where the car will detect openings before we launch the algorithm. Sometimes the car detects openings unpredictably, such as when it passes by an office with glass walls or when it goes down the ramp from Levine 3rd floor into Towne. This causes the car to prematurely take the next instruction set, which then interferes with the rest of the instruction sets. Hence we move on to localization and mapping next in search of a better solution to autonomous driving that doesn’t require as much human input and is more robust.</p>
</div>
</div>
<div class="section" id="gap-finding-in-lidar-scans-houssam">
<h2>Gap-finding in LiDAR Scans [Houssam]<a class="headerlink" href="#gap-finding-in-lidar-scans-houssam" title="Permalink to this headline">¶</a></h2>
<p>The topic on which lidar information messages are published is the <code class="docutils literal notranslate"><span class="pre">/scan</span></code> topic. If you run the <a class="reference internal" href="simulation.html#doc-going-forward-simulation"><span class="std std-ref">simulator</span></a> and run <code class="docutils literal notranslate"><span class="pre">$rostopic</span> <span class="pre">info</span> <span class="pre">/scan​</span></code>, you will see the messages are of type <code class="docutils literal notranslate"><span class="pre">std_msgs/LaserScan</span></code>.</p>
</div>
<div class="section" id="scan-matching-odometry-sheil">
<h2>Scan Matching Odometry [Sheil]<a class="headerlink" href="#scan-matching-odometry-sheil" title="Permalink to this headline">¶</a></h2>
<p>ROS’ ​laser_scan_matcher​ package performs scan matching odometry.</p>
<div class="section" id="installing-packages">
<h3>Installing Packages<a class="headerlink" href="#installing-packages" title="Permalink to this headline">¶</a></h3>
<p>Open a terminal and run the following commands to instal the required packages.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install ros-kinetic-amcl
$ sudo apt-get install ros-kinetic-scan-tools
</pre></div>
</div>
</div>
<div class="section" id="getting-the-example-launch-file">
<h3>Getting the Example Launch File<a class="headerlink" href="#getting-the-example-launch-file" title="Permalink to this headline">¶</a></h3>
<p>The f110 repo contains a launch file that demonstrates running the laser_scan_matcher on pre-recorded bag data. Copy it into your workspace’s <code class="docutils literal notranslate"><span class="pre">src/</span></code> folder, e.g.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ cp -r f110-course-upenn/algorithms/localization src/
</pre></div>
</div>
<p>This folder defines a package, ​localization, which uses ROS’ ​``laser_scan_matcher`` package.</p>
<p>Re-source your <code class="docutils literal notranslate"><span class="pre">setup.bash</span></code>, and you should be able to run</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ rospack find localization
</pre></div>
</div>
<p>The majority of the parameters in the ​``laser_scan_matcher​node`` are taken from the ROS docs on the ​​``laser_scan_matcher`` package, available <a class="reference external" href="https://wiki.ros.org/laser_scan_matcher#Parameters">here​</a>.</p>
<p>In order to run the <code class="docutils literal notranslate"><span class="pre">laser_scan_matcher​</span></code> on the pre-recorded bag file, execute the following lines in your terminal.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ roslaunch localization laser_scan_matcher.launch
</pre></div>
</div>
<p>If you don’t want to see RViz, change the <code class="docutils literal notranslate"><span class="pre">use_rviz</span></code> arg in the launch file to <code class="docutils literal notranslate"><span class="pre">“false”</span></code>. The rostopic printing the pose of the car and covariance matrix is called​ <code class="docutils literal notranslate"><span class="pre">/pose_with_covariance_stamped</span></code>. You can read about it online.</p>
</div>
</div>
<div class="section" id="localization">
<h2>Localization<a class="headerlink" href="#localization" title="Permalink to this headline">¶</a></h2>
<p>Now that we have information from the lidar, we can start to localize the car.</p>
<div class="section" id="localization-with-hector-slam">
<h3>Localization with Hector SLAM<a class="headerlink" href="#localization-with-hector-slam" title="Permalink to this headline">¶</a></h3>
<p>We use Hector SLAM in order to generate a map given a bag file. First install <code class="docutils literal notranslate"><span class="pre">hector-slam</span></code>.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ sudo apt-get install ros-kinetic-hector-slam
</pre></div>
</div>
<p>Run these following commands in order to reproduce it on your machine.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch localization hector_slam.launch
</pre></div>
</div>
<p>You will see an Rviz window open up that maps out the Moore Building 2nd floor loop. The launch file reads in a bag file which recorded all of the topics. Hector SLAM only needs the <code class="docutils literal notranslate"><span class="pre">/scan</span></code> topic (which contains the laser scans) in order to simultaneously map and localize. Note that no odometry data is used, whereas more advanced mapping packages such as Google Cartographer have the option to use odometry data and even IMU data.</p>
<p>Once the map is completely generated, in a new terminal window run the following in order to save the map as a yaml. The last string after “-f” is the name of the map you’d like to save. Since in this case we are using the Moore Building bag file, we appropriately name the map “moore”.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ rosrun map_server map_saver -f moore
</pre></div>
</div>
<p>Now you will see in your home directory a <code class="docutils literal notranslate"><span class="pre">levine.yaml</span></code> file and a <code class="docutils literal notranslate"><span class="pre">moore.pgm</span></code> file. You will need both of these. We have already copied and pasted a version of this under <code class="docutils literal notranslate"><span class="pre">localization/localization/maps/moore.yaml</span></code>, as well as its corresponding <code class="docutils literal notranslate"><span class="pre">moore.pgm</span></code> file.</p>
<p>Now that you have Hector SLAM working, we can dive a bit more into the details of the <code class="docutils literal notranslate"><span class="pre">hector_slam.launch</span></code> file. At the top of the file you will see that we set the parameter <code class="docutils literal notranslate"><span class="pre">/use_sim_time</span></code> to true because the launch file plays a bag file. In this case, it’s a bag file recorded while the car did a single loop around Moore. Whenever we play bag files, it’s important to include the –clock argument because it causes ROS to play bag files with simulated time synchronized to the bag messages (more information <a class="reference external" href="https://answers.ros.org/question/12577/when-should-i-need-clock-parameter-on-rosbag-play/%E2%80%8B">here</a>).</p>
<p>After the rosbag play instruction in the <code class="docutils literal notranslate"><span class="pre">hector_slam.launch</span></code> file, you will notice that there is a <code class="docutils literal notranslate"><span class="pre">tf2_ros</span></code> transform node that transforms between <code class="docutils literal notranslate"><span class="pre">base_link</span></code> to laser. This is very important to include or else Hector SLAM will not know where the laser is relative to the center of gravity of the car. In this case we use a static transform since the laser does not move relative to the car.</p>
<p>After the <code class="docutils literal notranslate"><span class="pre">tf2_ros</span></code> transform instruction in the launch file, you will see a reference to the <code class="docutils literal notranslate"><span class="pre">hector_mapping</span> <span class="pre">mapping_default.launch</span></code> file with parameters that specify the names of the <code class="docutils literal notranslate"><span class="pre">base_frame</span></code>, <code class="docutils literal notranslate"><span class="pre">odom_frame</span></code>, <code class="docutils literal notranslate"><span class="pre">map_size</span></code>, <code class="docutils literal notranslate"><span class="pre">scan_topic</span></code>, etc. Then there is a <code class="docutils literal notranslate"><span class="pre">hector_geotiff</span></code> which is used to save the map as a Geotiff file. Lastly, we launch rviz with a specific <code class="docutils literal notranslate"><span class="pre">rviz_cfg</span></code> (Rviz configuration) so that we don’t have to select all the topics we want to visualize every time weopen up Rviz. As a special note of interest, in algorithms below if you see in the launch file that there is a –delay of a few seconds added to Rviz, the reason is probably that we need to give Rviz time for certain nodes that generally take longer to publish to start publishing, otherwise Rviz will get old data.</p>
<p>If your hector_slam.launch isn’t working correctly, a good way to debug is to compare your <code class="docutils literal notranslate"><span class="pre">rqt_graph</span></code> and <code class="docutils literal notranslate"><span class="pre">rqt_tf_tree</span></code> to the ones we have screenshotted below.</p>
<div class="figure">
<img alt="../_images/hectorslam1.jpg" src="../_images/hectorslam1.jpg" />
</div>
<p>Rqt_graph for Hector SLAM generated by running “rosrun rqt_graph rqt_graph”</p>
<div class="figure">
<img alt="../_images/hectorslam2.jpg" src="../_images/hectorslam2.jpg" />
</div>
<p>Rqt_tf_tree generated for Hector SLAM by running “rosrun rqt_tf_tree rqt_tf_tree”</p>
</div>
<div class="section" id="localization-with-amcl-adaptive-monte-carlo-localization">
<h3>Localization with AMCL (Adaptive Monte Carlo Localization)<a class="headerlink" href="#localization-with-amcl-adaptive-monte-carlo-localization" title="Permalink to this headline">¶</a></h3>
<p>Now that we have generated our map, the next step is to be able to localize the car within the map. Now you may ask, if we already did SLAM, then why don’t we use Hector SLAM to simultaneously localize and map each time this is run? The reason is that Hector SLAM is computationally intensive, and we don’t wish to generate a new map each time we run the car. Since we assume the world does not change (after all, walls do not break down very often), we only want to localize the car within the fixed world. In order to localize the car, we use an algorithm called AMCL (Adaptive Monte Carlo Localization).</p>
<p>First install amcl for ROS.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ sudo apt-get install ros-kinetic-amc1
</pre></div>
</div>
<p>Next, run the launch file for amcl we have created. Note that we do not want roscore running because amcl will create its own ROS master. If we have two ROS masters there will probably be interference problems and hence AMCL will not run correctly.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch localization amcl.launch
</pre></div>
</div>
<p>You should see Rviz open up after a delay of 5 seconds (which we purposely set in order to make sure everything is loaded, specifically the map server). Then, you will see the map appear and the car moving through the map with green particles around it. In Rviz, on the top center click on 2D Pose Estimate, then click and drag on where the car starts. It is important to set the initial pose because if we don’t then the car will start at the origin and its localization will be wrong. In the moore.yaml map, the car starts at the bottom center T-shaped crossroads, facing to the left. The car will do clockwise loop back to its original location.</p>
<div class="figure">
<img alt="../_images/amcl1.jpg" src="../_images/amcl1.jpg" />
</div>
<p>Setting an initial 2D pose estimate for AMCL. Top bar, fourth button. Then click and drag in the map.</p>
<p>In the end, you should see a path that looks something like this image below. It won’t be perfect because <a class="reference external" href="http://wiki.ros.org/amcl%E2%80%8B">AMCL</a> requires a <code class="docutils literal notranslate"><span class="pre">/tf</span></code> (transform) topic. The best way we have to generate the <code class="docutils literal notranslate"><span class="pre">/tf</span></code> is to use the <code class="docutils literal notranslate"><span class="pre">/vesc/odom</span></code> topic, which literally counts the number of wheel spins and degree turns in order to estimate odometry. VESC odometry is not the most accurate because errors accumulate over time, but it gives a good general direction that guides AMCL with a general location for our car. We then used a messagetotf node in order to convert the <code class="docutils literal notranslate"><span class="pre">/vesc/odom</span></code> into <code class="docutils literal notranslate"><span class="pre">/tf</span></code> so that it can be used by AMCL.</p>
<p>Now that you have AMCL working successfully, time for some details on what’s going behind the scenes in the <code class="docutils literal notranslate"><span class="pre">amcl.launch</span></code> file. Like when we ran Hector SLAM, since we are playing this off of a bag file we need to set the <code class="docutils literal notranslate"><span class="pre">/use_sim_time</span> <span class="pre">parameter</span></code> to true. We also load a <code class="docutils literal notranslate"><span class="pre">map_server</span></code> node in order to publish the moore.yaml map. Note that we include the same <code class="docutils literal notranslate"><span class="pre">base_link_to_laser</span></code> transform as the one we provided Hector SLAM. After that line in the launch file is loading the amcl node, where we kept all the numerical parameters the same and only modified the <code class="docutils literal notranslate"><span class="pre">base_frame_id</span></code> and added initial pose x, y, and a. A is the orientation of the car relative to the map frame. You can read more on these in the <a class="reference external" href="http://wiki.ros.org/amcl%E2%80%8B">AMCL page</a> for information on each parameter.</p>
<p>If your AMCL isn’t working, it’s a good idea to compare your rqt_graph and rqt_tf_tree to the ones we have included screenshots of below.</p>
<div class="figure">
<img alt="../_images/amcl2.jpg" src="../_images/amcl2.jpg" />
</div>
<p>This is what the <code class="docutils literal notranslate"><span class="pre">rqt_tf_tree</span></code> looks like. You can verify if yours looks like this too by running​ <code class="docutils literal notranslate"><span class="pre">rosrun</span> <span class="pre">rqt_tf_tree</span> <span class="pre">rqt_tf_tree</span></code> in another terminal window while AMCL is running.</p>
<div class="figure">
<img alt="../_images/amcl3.jpg" src="../_images/amcl3.jpg" />
</div>
<p>This is the rqt graph generated by running in a new terminal window ​``rosrun rqt_graph rqt_graph``.</p>
<div class="figure">
<img alt="../_images/amcl4.jpg" src="../_images/amcl4.jpg" />
</div>
<p>Now that we can localize the car in a map, what’s next? Well, we can do really cool things! We can set waypoints for the car to follow, and those waypoints can have information not just about location but also speed at each point on the track. The car can use some type of pure pursuit algorithm in order to traverse from waypoint to waypoint. These will all be covered in the next sections.</p>
</div>
<div class="section" id="localization-with-particle-filter-faster-and-more-accurate-than-amcl">
<h3>Localization with Particle Filter (Faster and More Accurate than AMCL)<a class="headerlink" href="#localization-with-particle-filter-faster-and-more-accurate-than-amcl" title="Permalink to this headline">¶</a></h3>
<p>Why might you want to upgrade from AMCL to MIT particle filter? For one, AMCL only updates at around 4 times per second, whereas particle filter updates around 30 times per second. Additionally, particle filter uses the GPU whereas AMCL only uses the CPU. This results in the ability to use around 100x the number of particles, which results in more accuracy in localization. When we tried to use AMCL for localization with pure pursuit, we ran into challenges where we weren’t receiving any messages on the estimated pose topic because the car had not moved a certain threshold distance. When we set that threshold in AMCL parameters to be lower, the localization performance lagged. Hence we have been using the particle filter code written by Corey Walsh. The code follows this <a class="reference external" href="https://arxiv.org/abs/1705.01167">publication</a>.</p>
<p>Follow instructions <a class="reference external" href="https://github.com/mit-racecar/particle_filter">here</a> to install <code class="docutils literal notranslate"><span class="pre">RangeLibc</span></code> and other dependencies for particle filter.</p>
<p>Once you have installed the dependencies, there is no need to install the source code because we have already included it inside of the <code class="docutils literal notranslate"><span class="pre">/src/algorithms/particle_filter</span></code>. To see a demo of the particle filter in action, navigate to the terminal and type in the following launch command.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch localization particle_filter.launch
</pre></div>
</div>
<p>You can expect to see something like this:</p>
<div class="figure">
<img alt="../_images/pf1.jpg" src="../_images/pf1.jpg" />
</div>
<p>An Rviz window opens up with a map and particles (in red), indicating where the car is in the world. The <code class="docutils literal notranslate"><span class="pre">particle_filter.launch</span></code> file is playing back a rosbag, so you should see the car and particles moving around the map in a counter-clockwise fashion. In the <code class="docutils literal notranslate"><span class="pre">article_filter.launch</span></code> file we manually send a message to <code class="docutils literal notranslate"><span class="pre">/initialpose</span></code> topic but if you want to set it yourself in Rviz you can select the 2D Pose Estimate button on the top (4th button from the left) and click and drag in the map.</p>
<p>If you wanted to try it out in the real world with a joystick to see the localization live, you can run the <code class="docutils literal notranslate"><span class="pre">particle_filter_live.launch</span></code> file like this:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch localization particle_filter_live.launch
</pre></div>
</div>
<p>The difference between <code class="docutils literal notranslate"><span class="pre">particle_filter_live.launch</span></code> and <code class="docutils literal notranslate"><span class="pre">particle_filter.launch</span></code> is <code class="docutils literal notranslate"><span class="pre">particle_filter_live.launch</span></code> doesn’t play a rosbag, doesn’t use simulated time, and instead includes the teleop.launch file. Everything else is the same.</p>
<p>Now that you have the <code class="docutils literal notranslate"><span class="pre">particle_filter.launc</span></code> working, let’s examine the contents of the file more carefully. You will notice many overlaps between <code class="docutils literal notranslate"><span class="pre">particle_filter.launch</span></code> and <code class="docutils literal notranslate"><span class="pre">amcl.launch</span></code> and <code class="docutils literal notranslate"><span class="pre">hector_slam.launch</span></code>. For instance, you will recognize the map server, the <code class="docutils literal notranslate"><span class="pre">/use_sim_time</span></code> parameter, the rosbag and the static transform between base_footprint to laser. Note that in <code class="docutils literal notranslate"><span class="pre">particle_filter.launch</span></code> we use the name <code class="docutils literal notranslate"><span class="pre">base_footprin</span></code> instead of <code class="docutils literal notranslate"><span class="pre">base_link</span></code> because particle filter calls it the <code class="docutils literal notranslate"><span class="pre">base_footprint</span></code>. Then we load the <code class="docutils literal notranslate"><span class="pre">particle_filter</span></code> node with a few arguments. We tell <code class="docutils literal notranslate"><span class="pre">particle_filter</span></code> that our <code class="docutils literal notranslate"><span class="pre">scan_topic</span></code> is called <code class="docutils literal notranslate"><span class="pre">/scan</span></code> and that our odometry topic is called <code class="docutils literal notranslate"><span class="pre">/vesc/odom</span></code>. We keep the <code class="docutils literal notranslate"><span class="pre">max_particles</span></code> of 4,000 at the default number. Below are screenshots of the <code class="docutils literal notranslate"><span class="pre">rqt_tf_tree</span></code> and <code class="docutils literal notranslate"><span class="pre">rqt_graph</span></code>.</p>
<p>What if we want to run particle filter with a slower update rate? (In order to appreciate the speed that the GPU offers or to simulate on a slower computer). Inside the particle_filter.launch file, you can change the “range_method” from “rmgpu” to “bl”. As documented on the particle filter Github repo, “bl” does not use the GPU and has much less particles. Our testing shows that “bl” achieves an inferred_pose update rate of around 7Hz, whereas “rmgpu” achieves 40Hz.</p>
<div class="figure">
<img alt="../_images/pf2.jpg" src="../_images/pf2.jpg" />
</div>
<p>Rqt_graph for particle filter</p>
<div class="figure">
<img alt="../_images/pf3.jpg" src="../_images/pf3.jpg" />
</div>
<p>Rqt_tf_tree for particle filter</p>
</div>
</div>
<div class="section" id="working-with-waypoints">
<h2>Working with Waypoints<a class="headerlink" href="#working-with-waypoints" title="Permalink to this headline">¶</a></h2>
<div class="section" id="generating-waypoints">
<h3>Generating Waypoints<a class="headerlink" href="#generating-waypoints" title="Permalink to this headline">¶</a></h3>
<p>Now that we have localization down, the next step is to be able to follow a set of waypoints. The waypoints are (x, y) coordinates with respect to the map frame. We can expect around 2,000 - 4,000 waypoints for a loop of length around 66 meters.</p>
<p>Do the following to save waypoints.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># ​ Allow the car to be controlled with joystick</span>
$​ roslaunch racecar teleop.launch

<span class="c1">#​ Record a rosbag with just the scan and vesc/odom topics. Will be saved</span>
into your Home directory. <span class="o">(</span>In a new terminal window<span class="o">)</span>
$​ rosbag record scan vesc/odom

<span class="c1"># You will need to modify particle_filter.launch with path to rosbag you</span>
just recorded
$ roslaunch localization particle_filter.launch

<span class="c1"># Records waypoints and saves as waypoints.csv in current working directory</span>
$​ rosrun waypoint_logger waypoint_logger.py
</pre></div>
</div>
<p>At this point, in your current working directory you will see a csv file called <code class="docutils literal notranslate"><span class="pre">waypoints.csv</span></code>. Let’s go into further detail on what is going behind the scenes. <code class="docutils literal notranslate"><span class="pre">Particle_filter.launch</span></code> plays the rosbag that you recorded (of course, you have to update the particle_filter.launch with the path to your bag file you recorded). The particle filter subscribes to the <code class="docutils literal notranslate"><span class="pre">vesc/odom</span></code> and scan topics, and it outputs a stream of messages over the topic <code class="docutils literal notranslate"><span class="pre">pf/viz/inferred_pose</span></code>. <code class="docutils literal notranslate"><span class="pre">Waypoint_logger.py</span></code> subscribes to <code class="docutils literal notranslate"><span class="pre">pf/viz/inferred_pose</span></code> and saves the x, y coordinates in each callback to a CSV file.</p>
<p>Now that you have your <a href="#id3"><span class="problematic" id="id4">``</span></a>waypoints.csv <a href="#id5"><span class="problematic" id="id6">``</span></a>file, the next step will be to use this list of waypoints and have the car follow them using pure pursuit.</p>
</div>
<div class="section" id="following-waypoints-with-pure-pursuit">
<h3>Following Waypoints with Pure Pursuit<a class="headerlink" href="#following-waypoints-with-pure-pursuit" title="Permalink to this headline">¶</a></h3>
<p>Now this is the really exciting part.</p>
<p>Before you run the <code class="docutils literal notranslate"><span class="pre">pure_pursuit.launch</span></code> file, you will need to change the path to the map you would like loaded in <code class="docutils literal notranslate"><span class="pre">pure_pursuit.launch</span></code>. Additionally, you can also set the initial position of the car in the map frame. That way, you don’t need to manually draw it out each time in Rviz. By default we will set a map and initial pose so that you can see the pure pursuit running.</p>
<p>Additionally, inside of <code class="docutils literal notranslate"><span class="pre">pure_pursuits.py</span></code>, you will need to update the path to the waypoints file that you would like to use. In <code class="docutils literal notranslate"><span class="pre">pure_pursuits.py</span></code> you can also set a velocity. We recommend starting with something slow like 0.5 m/s with a lookahead distance of 1.5 meters.</p>
<p>Now you are ready to run the launch command to start the car moving.</p>
<p>To run in the simulator (recommended to do this first):</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch pure_pursuit pure_pursuit_sim.launch
</pre></div>
</div>
<p>Note that the Gazebo simulator works well with pure pursuit algorithm only at slower speeds, around 1 m/s on turns and less than 4 m/s on straightaways. The reason is that on turns with higher speeds than 1 m/s, Gazebo models the car as sliding out more with a much larger turn radius. We’ve tried a dozen ways to try to fix this overestimation of turning drift, but with no success. Hence we use Gazebo mainly to test that algorithms work at slower speeds, then take the car into real world to slowly ramp up the speed.</p>
<p>Another thing to note is that in the simulator we are using the true (x, y) position of the car by listening to the topic <code class="docutils literal notranslate"><span class="pre">/gazebo/model_states</span></code> and remapping the information to <code class="docutils literal notranslate"><span class="pre">/pf/viz/inferred_pose</span></code> (which would normally be output by particle filter). It is fair to expect that particle filter is not perfect in the real world and may have some noise. Hence inside <code class="docutils literal notranslate"><span class="pre">/algorithms/pure_pursuit/scripts</span></code> we have a <code class="docutils literal notranslate"><span class="pre">remap_gazebo_pose.py</span></code> and a <code class="docutils literal notranslate"><span class="pre">remap_gazebo_pose_with_noise.py</span></code>. By default <code class="docutils literal notranslate"><span class="pre">pure_pursuit_sim.launch</span></code> calls the <code class="docutils literal notranslate"><span class="pre">remap_gazebo_pose.py</span></code> (the one without noise) but if you would like to try the one with noise you can replace the line in the launch file to point to <code class="docutils literal notranslate"><span class="pre">remap_gazebo_pose_with_noise.py</span></code>. The parameters for the Gaussian XY variance and rotation variance can be adjusted within that python file.</p>
<p>To run in the real world:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch pure_pursuit pure_pursuit.launch
</pre></div>
</div>
<p>All of the core logic for <code class="docutils literal notranslate"><span class="pre">pure_pursuit</span></code> is contained in the <code class="docutils literal notranslate"><span class="pre">pure_pursuit.py</span></code> file which can be found under <code class="docutils literal notranslate"><span class="pre">algorithms/pure_pursuit/scripts</span></code>. From a high level, the pseudocode for pure pursuit is like <a class="reference external" href="https://www.ri.cmu.edu/pub_files/pub3/coulter_r_craig_1992_1/coulter_r_craig_1992_1.pdf">this</a>.</p>
<ol class="arabic simple">
<li>Determine the location of the vehicle (provided by particle filter localization).</li>
<li>Find the path point closest to the vehicle.</li>
<li>Find the goal point.</li>
<li>Transform the goal point to vehicle coordinates.</li>
<li>Calculate the curvature for the car to steer to reach that goal point.</li>
<li>Update the vehicle’s position.</li>
</ol>
<p>The most challenging part of the algorithm was transforming the goal point to vehicle coordinates. There probably is some library out there to do this, but we weren’t able to find it trivially and thought it’d be a sound learning exercise to try to implement it ourselves so we could explain it to you in this doc. Below is a picture of a whiteboard which shows the math behind deriving the goal point coordinates with respect to the car’s frame. We calculate the angle gamma, defined as the direction to goal point in car’s frame with respect to the x-axis, because using gamma we can derive the goal point coordinates with respect to the car’s frame.</p>
<p>Note that there are also limitations for our pure pursuit algorithm. Here is a list of them:</p>
<p>#.Car is at constant velocity, on straightaways and turns. Ideally we want faster straightaways and slower turns.
#.Look ahead distance is constant for straightaways and turns. We probably want a farther lookahead distance for straightaways so car doesn’t oscillate left and right when it goes faster, and a smaller look ahead distance for turns so car doesn’t look too far ahead and end up cutting off a corner too tight and hitting the wall.
#.We want the code to be able to do loop closure, that is have the car know when it is completing a loop and continue back to the first index.</p>
<p>Improvements are made that address these limitations in the next section, on pure pursuit with speed control.</p>
<div class="figure">
<img alt="../_images/pp1.jpg" src="../_images/pp1.jpg" />
</div>
</div>
<div class="section" id="pure-pursuit-speed-control-algorithm">
<h3>Pure Pursuit Speed Control Algorithm<a class="headerlink" href="#pure-pursuit-speed-control-algorithm" title="Permalink to this headline">¶</a></h3>
<p>Our implementation of pure pursuit with speed control (<code class="docutils literal notranslate"><span class="pre">purepursuitwithspeedcontrol.py</span></code>) allows the car to go faster in straight hallways and slow down in turns. The car is following a set of waypoints (x, y) coordinates.</p>
<p>To run the pure pursuit with speed control:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch pure_pursuit pure_pursuit_with_speed_control.launch
</pre></div>
</div>
<p>The car examines the points ahead of it within the search window defined by the constants <code class="docutils literal notranslate"><span class="pre">WP_TURN_WINDOW_MIN</span></code> and <code class="docutils literal notranslate"><span class="pre">WP_TURN_WINDOW_MAX</span></code> and takes the average x-coordinate of those points. (You can think of <code class="docutils literal notranslate"><span class="pre">WP_TURN_WINDOW_MIN</span></code> as being the radius of the inner circle of the region to check and <code class="docutils literal notranslate"><span class="pre">WP_TURN_WINDOW_MAX</span></code> as being the radius of the outer circle. See the diagram below.) The amount that the car slows down depends on how steep the turn is: if the turn is steeper (that is, the average x-coordinate is far from the car’s centerline), the car will slow down more; if the turn is shallow, it will slow down less. For smooth speed adjustment, the speed is interpolated between the maximum straightaway speed (<code class="docutils literal notranslate"><span class="pre">VELOCITY_STRAIGHT</span></code>) and the minimum turn speed (<code class="docutils literal notranslate"><span class="pre">VELOCITY_TURN</span></code>).</p>
<p>Below is a visual explanation of the speed adjustment algorithm.</p>
<ol class="arabic">
<li><p class="first">The car is driving in a straightaway and hasn’t entered a turn yet (lots of path points on the centerline): proceed at full speed. (4 m/s)</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/pp2.jpg" src="../_images/pp2.jpg" />
</div>
</div></blockquote>
</li>
<li><p class="first">The car has begun entering a turn: start slowing down (3 m/s)</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/pp3.jpg" src="../_images/pp3.jpg" />
</div>
</div></blockquote>
</li>
<li><p class="first">The car is now fully in the turn: slow down to near the minimum speed (2 m/s)</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/pp4.jpg" src="../_images/pp4.jpg" />
</div>
</div></blockquote>
</li>
<li><p class="first">The car is starting to exit the turn: speed up a little bit (3 m/s)</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/pp5.jpg" src="../_images/pp5.jpg" />
</div>
</div></blockquote>
</li>
<li><p class="first">The car has exited the turn: drive at full speed again (4 m/s)</p>
<blockquote>
<div><div class="figure">
<img alt="../_images/pp6.jpg" src="../_images/pp6.jpg" />
</div>
</div></blockquote>
</li>
</ol>
</div>
</div>
<div class="section" id="path-planning">
<h2>Path Planning<a class="headerlink" href="#path-planning" title="Permalink to this headline">¶</a></h2>
<p>At this point we have been able to run pure pursuit relatively fast (up to 6 m/s) following a pre-generated set of waypoints. Before, we were generating waypoints by manually driving the desired car path beforehand, and then generating the list of (x, y) coordinates by localizing withparticle filter. But what if we want to be able to dynamically generate waypoints, without having had driven the car beforehand? What if we want the car to be able to dynamically generate paths that can navigate around unseen obstacles? This is where things get even more fun!</p>
<div class="section" id="path-planning-with-ros-move-base">
<h3>Path Planning with ROS move_base<a class="headerlink" href="#path-planning-with-ros-move-base" title="Permalink to this headline">¶</a></h3>
<p>We use ROS ​``move_base`` to incorporate a global planner and a local planner. Almost everything in this section is taken from the official ROS tutorial on setting up move_base. It’s a very important document. We’ve literally read it at least 10 times.</p>
<p>Install move_base by running:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ sudo apt-get install ros-kinetic-move-base
</pre></div>
</div>
<p>To see <code class="docutils literal notranslate"><span class="pre">move_base</span></code> running in the simulator, type this in your terminal:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch path_planning move_base_sim.launch
</pre></div>
</div>
<p>When you launch this file, you will see both Gazebo and Rviz open up. You may also see a list of yellow warning messages that an “Invalid argument passed to canTransform argument source_frame in tf2 frame_ids cannot be empty”. We haven’t yet figured out how to fix this, but the car seems to run fine in the simulator even with the warning message.</p>
<p><code class="docutils literal notranslate"><span class="pre">Move_base_sim.launch</span></code> calls a Python file called <code class="docutils literal notranslate"><span class="pre">follow_move_base_cmd_vel.py</span></code> which subscribes to the <code class="docutils literal notranslate"><span class="pre">/cmd_vel</span></code> topic. <code class="docutils literal notranslate"><span class="pre">/cmd_vel</span></code> is published by <code class="docutils literal notranslate"><span class="pre">move_base</span></code>’s local planner and is a list of Twist messages which basically tells the car what x, y, z velocities and what x, y, z angular velocities to move at. The strategy here is to just take these output values in order to compute the car velocity and steering angle. The equations are as follows:</p>
<blockquote>
<div><p>Velocity = sqrt(x^2 + y^2)
Steering angle = atan2(WHEELBASE_LENGTH * theta_dot</p>
<blockquote>
<div>/ velocity), where theta_dot is the z angular velocity (aka yaw)</div></blockquote>
</div></blockquote>
<p>Note that because the default local planner in move_base is designed for differential drive robots (robots that can spin in place, like the Roomba vacuum cleaner robots), the paths that are generated are not ideal for our car which is an Ackermann steering robot. Hence in the next section we will talk about the TEB (Timed Elastic Band) local planner which can be used for Ackermann robots. But before we get there, you may also want to test out move_base in the real world.</p>
<p>To see move_base running in the real world, run the following:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ roslaunch path_planning pure_pursuit_local_plan.launch
</pre></div>
</div>
<p>You should see Rviz open with a map of Levine Hall 2nd floor. Note that this launch file is meant for running the car live, as in in the real world. If you are running this on your car, in order to get the car to move, we have added a dead man’s switch onto the joystick. The car doesn’t move unless we hold down the “RB” button on the top right of the joystick. The strategy for the car to follow the local plan here is different from the strategy used in the simulator above. Earlier in the simulator we subscribed to the <code class="docutils literal notranslate"><span class="pre">/cmd_vel</span></code> topic which literally gave us the velocity and steering angle to follow. Here our strategy is to take the global plan which is a list of Pose data type, and use our pure pursuit code from an earlier section. The biggest challenge with pure pursuit for us is that with too great of a lookahead distance (in this case greater than 1 meter), the car will run into corners on turns because it sees waypoints too far in front. This is a problem because if we turn the lookahead distance to something smaller, then the car oscillates a lot going down straightaways. Hence this code isn’t ideal for any type of racing, but is merely to demonstrate the differences in the two strategies for following the generated paths. The first strategy is blindly following the <code class="docutils literal notranslate"><span class="pre">/cmd_vel</span></code> output by move_base. The second strategy is to take the list of waypoints (poses) and use pure pursuit to follow them.</p>
<p>In order to get the car to drive in a loop by path planning, we wrote a script called <code class="docutils literal notranslate"><span class="pre">send_goal_poses.py</span></code>. This file spawns a <code class="docutils literal notranslate"><span class="pre">move_base</span></code> action server which publishes a series of 3 nav goals. The trick is that the <code class="docutils literal notranslate"><span class="pre">move_base</span></code> server - because it knows when the car has reached its current nav goal - will then send the next nav goal once the car has reached the previous one. Once the car reaches the last nav goal (which is represented by x and y coordinates), then the count resets to 0 for the car to fetch the first nav goal. Something important here is that we had to tune the <code class="docutils literal notranslate"><span class="pre">xy_goal_tolerance</span></code> and the <code class="docutils literal notranslate"><span class="pre">yaw_goal_tolerance</span></code> parameters in the yaml file so that the car will register as reaching its goal within 2.0 meters of the goal, and within 180 degrees yaw of the nav goal. We want a larger <code class="docutils literal notranslate"><span class="pre">xy_goal_tolerance</span></code> of 2.0 meters so that the car can begin planning its next path when it has almost reached the current nav goal. And we set the <code class="docutils literal notranslate"><span class="pre">yaw_goal_tolerance</span></code> to the max value because for sake of simplicity we only send the x, y coordinates of nav goals. We don’t send the orientation of nav goals. It’s also important to mention that when we set the list of nav goals, to get the coordinates we just dragged initial poses in Rviz of where we wanted the car to go, and copied the x, y coordinates displayed in the terminal.</p>
<p>We wrote a <code class="docutils literal notranslate"><span class="pre">pure_pursuit_path_planner.py</span></code> file in order to use pure pursuit to follow this generated path at a slow constant speed. Note that you will see a green path generated by the global planner. Specifically, the <code class="docutils literal notranslate"><span class="pre">pure_pursuit_path_planner.py</span></code> python file subscribes to 2 topics:</p>
<ol class="arabic simple">
<li><code class="docutils literal notranslate"><span class="pre">/pf/viz/inferred_pose</span></code> -&gt; This is the estimated pose published by particle filter (from an earlier section). Pure pursuit needs the robot’s estimated pose in order to know which waypoint to follow next and where that waypoint is in the car’s frame.</li>
<li><code class="docutils literal notranslate"><span class="pre">/move_base/TrajectoryPlannerROS/global_plan</span></code> -&gt; Published by move_base after setting a 2D nav goal, this is a list of Pose data type. Normally we see around 150 to 250 poses per message. We set the <code class="docutils literal notranslate"><span class="pre">global_plan</span></code> to update 20 times per second, so that it is fast enough to react to obstacles that appear.</li>
</ol>
<div class="figure">
<img alt="../_images/movebase1.jpg" src="../_images/movebase1.jpg" />
</div>
<p>This is an image of the <code class="docutils literal notranslate"><span class="pre">rqt_tf_tree</span></code>. Note that there is no odom frame because we purposely removed it for simplicity.</p>
<p>One other note on move_base: launch files that use move_base take in 4 yaml files found in the <code class="docutils literal notranslate"><span class="pre">/params</span></code> folder. These parameters were mainly set according to this <a class="reference external" href="http://wiki.ros.org/navigation/Tutorials/RobotSetup%E2%80%8B">tutorial</a>.</p>
<p>Included below is a screenshot of Rviz. Note the global costmap in blue, red, and purple that spans the entire map. And note the local costmap which spans a smaller 10 x 10 meter box (in grey). The path (difficult to see in the image) is a green line that starts from the front of the car and ends at the boundaries of the local costmap rolling box.</p>
<div class="figure">
<img alt="../_images/movebase2.jpg" src="../_images/movebase2.jpg" />
</div>
</div>
<div class="section" id="path-planning-with-teb-timed-elastic-band-local-planner">
<h3>Path Planning with TEB (Timed Elastic Band) Local Planner<a class="headerlink" href="#path-planning-with-teb-timed-elastic-band-local-planner" title="Permalink to this headline">¶</a></h3>
<p>We’ve just seen <code class="docutils literal notranslate"><span class="pre">move_base</span></code> working in the simulator and real world. The default local planner for <code class="docutils literal notranslate"><span class="pre">move_base</span></code> was designed for differential drive robots - not Ackermann carlike robots - so you may have noticed some of these problems when running move_base code earlier:</p>
<ol class="arabic simple">
<li>When the car got stuck facing a wall or was too close to a corner (and hence stuck in the high cost areas of the cost map), the car would just stop and didn’t know how to back up or get out of the situation.</li>
<li>Car might oscillate a lot going down straightaways</li>
<li>Turns are sometimes really wide, or sometimes cut corners very tightly. Because move_base local planner doesn’t have parameter for car turning radius.</li>
<li>If car overshoots a turn, meaning it’s supposed to turn but then its inertia carries it past the turn, the car can’t recover.</li>
<li>Placing obstacles in front of the car (like tennis ball cans), the car sometimes crashes into them.</li>
</ol>
<p>To address these problems, we use the <a class="reference external" href="http://wiki.ros.org/teb_local_planner">TEB (Timed Elastic Band)</a> local planner. TEB gets its name from the fact that it takes into account <em>time</em>, meaning that it plans trajectories instead of just paths. What is the difference between a trajectory and a path? A trajectory outputs not only x and y coordinates, but also the time when the robot needs to reach each point - and implicitly the velocity at each step. Whereas a path is just a list of x and y coordinates.</p>
<p>Install TEB:</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$​ sudo apt-get install ros-kinetic-teb-local-planner
</pre></div>
</div>
<p>TEB is a very thorough, well documented library with LOTS of parameters. Like over 40 parameters. We configured parameters in <code class="docutils literal notranslate"><span class="pre">algorithms/path_planning/params/teb_local_planner_params.yaml</span></code>. There are params for <code class="docutils literal notranslate"><span class="pre">min_turning_radius</span></code>, wheelbase of the car, <code class="docutils literal notranslate"><span class="pre">max_vel_x</span></code>, and much more. In our <code class="docutils literal notranslate"><span class="pre">follow_teb_local_plan.launch</span></code> file, under the <code class="docutils literal notranslate"><span class="pre">move_base</span></code> node we add a rosparam that loads the <code class="docutils literal notranslate"><span class="pre">teb_local_planner_params.yaml</span></code> and have removed the default local planner params file. The underlying python file, <code class="docutils literal notranslate"><span class="pre">follow_teb_local_plan.py</span></code>, is very similar to the <code class="docutils literal notranslate"><span class="pre">follow_move_base_cmd_vel.py</span></code> used for the default local planner. The main difference is that because Teb literally outputs the velocity and steering angle as is, we don’t need to do conversion.</p>
<p>Here are some of the really cool things that TEB enables us to do:</p>
<ol class="arabic simple">
<li>When the car gets stuck in an area of the map with high cost, the car can back up and get out of the situation. How cool!</li>
<li>When there are dynamic obstacles such as a person stopping in front of the car, the car will go around the person. Note that the default local planner could also do this, but TEB can do it better since the car can back up in case its turning radius is not big enough to clear the obstacle.</li>
<li>The car can actually race autonomously one on one with another car now. Because the car can plan around the other car for passing.</li>
<li>The car can do parallel parking (kind of). But it needs a lot of parameter tuning in terms of the min_obstacle_dist, the weight_kinetmatic_forward_drive, etc.</li>
</ol>
<p>All in all, TEB is just really cool!</p>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../contact.html" class="btn btn-neutral float-right" title="Contact" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="simulation.html" class="btn btn-neutral float-left" title="Simulation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2020, f1tenth community (CC-BY-NC-SA 4.0)

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>